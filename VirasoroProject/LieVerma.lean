/-
Copyright (c) 2025 Kalle Kytölä. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kalle Kytölä
-/
import Mathlib.Data.Sign
import VirasoroProject.LieAlgebraModuleUEA
import VirasoroProject.ToMathlib.LinearAlgebra.Basis.FinsumRepr
import VirasoroProject.VermaModule

/-!
# Verma modules for Lie algebras with triangular decomposition

This file defines Verma modules used in Lie algebra representation theory.

## Main definitions

* `TriangularDecomposition`: A triangular decomposition of a Lie algebra (typically to a
  commutative Cartan subalgebra and two nilpotent subalgebras, but these requirements are not
  bundled in the definition).
* `TriangularDecomposition.ofBasis`: The triangular decomposition of a Lie algebra `𝓰` associated
  with a tri-partition of a given basis of `𝓰`.
* `TriangularDecomposition.weight`: A weight of a Lie algebra `𝓰` with triangular decomposition is
  a linear functional on the Cartan subalgebra `𝓱 ⊆ 𝓰`.
* `TriangularDecomposition.VermaHW η`: The Verma module of highest weight `η` for a Lie algebra `𝓰`
  with a triangular decomposition.
* `TriangularDecomposition.VermaHW.hwVec`: The highest weight vector of the Verma module.
* `TriangularDecomposition.VermaHW.universalMap`: The universal property of the Verma module:
  Given another module `M` over `𝓤 𝕜 𝓰` and a "target" vector `hwv ∈ M` satisfying `E • hwv = 0`
  for all `E` in the positive part of the triangular decomposition and `H • hwv  = η(H) • hwv` for
  all `H` in the Cartan subalgebra, one obtains an `A`-module map from the Verma module to `M`
  uniquely specified by the requirement `hwVec η ↦ hwv`.

## Main statements

* `TriangularDecomposition.instModule𝓤VermaHW` and `TriangularDecomposition.instModuleVermaHW`:
  A Verma module of a Lie algebra `𝓰` is a module over the universal enveloping algebra `𝓤 𝕜 𝓰` and
  a vector space over `𝕜`.
* `TriangularDecomposition.VermaHW.hwVec_cyclic`: The Verma module is generated by its highest weight vector.
* `TriangularDecomposition.VermaHW.cartan_smul_hwVec`: The highest weight vector of a Verma module
  is an eigenvector of the Cartan subalgebra with the eigenvalues specified by the highest weight.
* `TriangularDecomposition.VermaHW.upper_smul_hwVec`: The highest weight vector of a Verma module
  is annihilated by the positive part of the triangular decomposition.
* `VermaModule.range_universalMap_eq_span`: The map guaranteed by the universal property
  of the Verma module is surjective onto the submodule generated by the "target" vector.

## Implementation notes

Verma modules over Lie algebras are defined as a special case of generalized Verma module for
algebras (see the file `VermaModule.lean`).

## Tags

Verma module, Lie algebra, representation

-/

namespace VirasoroProject



section

variable (𝕜 : Type*) [CommRing 𝕜]
variable (𝓰 : Type*) [LieRing 𝓰] [LieAlgebra 𝕜 𝓰]

/-- A triangular decomposition of a Lie algebra (without assumptions of commutativity
of the Cartan subalgebra or nilpotency of the other parts bundled, yet). -/
structure TriangularDecomposition where
  part : SignType → Submodule 𝕜 𝓰
  directSum : DirectSum.IsInternal part

namespace TriangularDecomposition

variable {𝕜 𝓰} in
def ofBasis {ι : Type*} [Nontrivial 𝕜] [NoZeroSMulDivisors 𝕜 𝓰]
    (B : Basis ι 𝕜 𝓰) (Bp : SignType → Set ι)
    (Bp_disj : Pairwise (fun ε₁ ε₂ ↦ Disjoint (Bp ε₁) (Bp ε₂)))
    (Bp_cover : ⋃ ε, Bp ε = Set.univ) :
    TriangularDecomposition 𝕜 𝓰 where
  part ε := Submodule.span 𝕜 (B '' Bp ε)
  directSum := by
    rw [DirectSum.isInternal_submodule_iff_iSupIndep_and_iSup_eq_top]
    constructor
    · exact B.iSupIndep_submodule_span_of_pairwise_disjoint _ Bp_disj
    · rw [Submodule.eq_top_iff']
      intro X
      have Xpart_mem (ε) : ∑ᶠ i ∈ Bp ε, B.repr X i • B i ∈ Submodule.span 𝕜 (B '' Bp ε) :=
        finsum_mem_mem_span (fun i ↦ B i) (B.repr X) (Bp ε)
      have X_eq :
          X = ∑ᶠ i ∈ Bp 1, B.repr X i • B i + ∑ᶠ i ∈ Bp (-1), B.repr X i • B i
              + ∑ᶠ i ∈ Bp 0, B.repr X i • B i := by
        nth_rw 1 [← B.finsum_repr_smul_basis X]
        have supp_finite_aux : (Function.support (fun i ↦ B.repr X i • B i)).Finite := by
          apply (Finsupp.finite_support (B.repr X)).subset
          intro i hi
          simp only [Function.support, ne_eq, smul_eq_zero, not_or, Set.mem_setOf_eq] at hi ⊢
          exact hi.1
        have supp_finite (ε : SignType) := supp_finite_aux.inter_of_right (Bp ε)
        rw [← finsum_mem_union' (Bp_disj (by simp)) (supp_finite 1) (supp_finite (-1))]
        rw [← finsum_mem_union' ?_ ?_ (supp_finite 0)]
        · have Bp_cover' : Bp 1 ∪ Bp (-1) ∪ Bp 0 = Set.univ := by
            rw [← Bp_cover]
            apply subset_antisymm
            · refine Set.union_subset (Set.union_subset ?_ ?_) ?_ <;>
              · exact Set.subset_iUnion_of_subset _ subset_rfl
            · apply Set.iUnion_subset
              intro ε
              match ε with
              | 1 => apply Set.subset_union_of_subset_left (by simp)
              | 0 => simp
              | -1 => apply Set.subset_union_of_subset_left (by simp)
          simp [Bp_cover']
        · exact Disjoint.union_left (Bp_disj (by simp)) (Bp_disj (by simp))
        · exact Set.Finite.inter_of_right supp_finite_aux (Bp 1 ∪ Bp (-1))
      rw [X_eq]
      apply Submodule.add_mem _ (Submodule.add_mem _ ?_ ?_)
      · exact Submodule.mem_iSup_of_mem 0 (Xpart_mem 0)
      · exact Submodule.mem_iSup_of_mem 1 (Xpart_mem 1)
      · exact Submodule.mem_iSup_of_mem (-1) (Xpart_mem (-1))

variable {𝕜 𝓰} in
/-- The parts of a triangular decomposition determined by a basis have natural bases by
construction. -/
noncomputable def ofBasis.basis_part {ι : Type*} [Nontrivial 𝕜] [NoZeroSMulDivisors 𝕜 𝓰]
    (B : Basis ι 𝕜 𝓰) (Bp : SignType → Set ι)
    (Bp_disj : Pairwise (fun ε₁ ε₂ ↦ Disjoint (Bp ε₁) (Bp ε₂)))
    (Bp_cover : ⋃ ε, Bp ε = Set.univ) (ε : SignType) :
    Basis (Bp ε) 𝕜 ((ofBasis B Bp Bp_disj Bp_cover).part ε) :=
  Basis.basis_submodule_span B (Bp ε)

variable {𝕜 𝓰}
variable (tri : TriangularDecomposition 𝕜 𝓰)

/-- The Cartan subalgebra of a given triangular decomposition of a Lie algebra. -/
abbrev cartan := tri.part 0

abbrev upper := tri.part 1

abbrev lower := tri.part (-1)

/-- Weights of a Lie algebra with triangular decomposition are functionals on the
Cartan subalgebra. -/
abbrev weight := tri.cartan →ₗ[𝕜] 𝕜

variable {tri}

/-- The data associated to a weight for the purpose of constructing a highest weight
representation. -/
noncomputable def weightHW (η : weight tri) (i : tri.cartan ⊕ tri.upper) :
    𝓤 𝕜 𝓰 × 𝕜 := match i with
  | Sum.inl H => ⟨ιUEA 𝕜 H, η H⟩
  | Sum.inr E => ⟨ιUEA 𝕜 E, 0⟩

/-- The Verma module of highest weight η. -/
def VermaHW (η : weight tri) :=
  VermaModule (weightHW η)

variable (η : weight tri)

/-- The highest weight vector of the Verma module of highest weight η. -/
noncomputable def VermaHW.hwVec (η : weight tri) : VermaHW η :=
  VermaModule.hwVec _

noncomputable instance (η : weight tri) : AddCommGroup (VermaHW η) :=
  instAddCommGroupVermaModule _

noncomputable instance (η : weight tri) :
    Module (𝓤 𝕜 𝓰) (VermaHW η) :=
  instModuleVermaModule _

noncomputable instance (η : weight tri) :
    Module 𝕜 (VermaHW η) :=
  moduleScalarOfModule 𝕜 (𝓤 𝕜 𝓰) (VermaHW η)

instance (η : weight tri) :
    IsScalarTower 𝕜 (𝓤 𝕜 𝓰) (VermaHW η) :=
  isScalarTowerModuleScalarOfModule 𝕜 (𝓤 𝕜 𝓰) (VermaHW η)

lemma VermaHW.smul_eq_algebraHom_smul {η : weight tri} (r : 𝕜) (v : VermaHW η) :
    r • v = (algebraMap 𝕜 (𝓤 𝕜 𝓰) r) • v :=
  rfl

instance (η : weight tri) :
    SMulCommClass 𝕜 (𝓤 𝕜 𝓰) (VermaHW η) where
  smul_comm r a v := by
    simp_rw [VermaHW.smul_eq_algebraHom_smul]
    simp only [← smul_assoc, smul_eq_mul, Algebra.commutes r a]

lemma VermaHW.hwVec_cyclic (η : weight tri) :
    Submodule.span (𝓤 𝕜 𝓰) {VermaHW.hwVec η} = ⊤ :=
  VermaModule.hwVec_cyclic _

lemma VermaHW.upper_smul_hwVec (η : weight tri) {E : 𝓰} (hE : E ∈ tri.upper) :
    ιUEA 𝕜 E • VermaHW.hwVec η = 0 := by
  simpa [weightHW] using VermaModule.apply_hwVec_eq (weightHW η) (Sum.inr ⟨E, hE⟩)

lemma VermaHW.cartan_smul_hwVec (η : weight tri) {H : 𝓰} (hH : H ∈ tri.cartan) :
    ιUEA 𝕜 H • VermaHW.hwVec η = (η ⟨H, hH⟩) • VermaHW.hwVec η := by
  simpa [weightHW] using VermaModule.apply_hwVec_eq (weightHW η) (Sum.inl ⟨H, hH⟩)

noncomputable def VermaHW.universalMap (η : weight tri)
    (M : Type*) [AddCommGroup M] [Module (𝓤 𝕜 𝓰) M] {hwv : M}
    (hwv_cartan : ∀ {H} (hH : H ∈ tri.cartan),
      ιUEA 𝕜 H • hwv = (algebraMap 𝕜 (𝓤 𝕜 𝓰) (η ⟨H, hH⟩) • hwv))
    (hwv_upper : ∀ {E} (_ : E ∈ tri.upper), ιUEA 𝕜 E • hwv = 0) :
    VermaHW η →ₗ[𝓤 𝕜 𝓰] M :=
  VermaModule.universalMap (weightHW η) (hwv := hwv) <| by
    intro i
    match i with
    | Sum.inl H => simpa [weightHW] using hwv_cartan (Submodule.coe_mem H)
    | Sum.inr E => simpa [weightHW] using hwv_upper (Submodule.coe_mem E)

lemma VermaHW.universalMap_hwVec (η : weight tri)
    (M : Type*) [AddCommGroup M] [Module (𝓤 𝕜 𝓰) M] {hwv : M}
    (hwv_cartan : ∀ {H} (hH : H ∈ tri.cartan),
      ιUEA 𝕜 H • hwv = (algebraMap 𝕜 (𝓤 𝕜 𝓰) (η ⟨H, hH⟩) • hwv))
    (hwv_upper : ∀ {E} (_ : E ∈ tri.upper), ιUEA 𝕜 E • hwv = 0) :
    VermaHW.universalMap η M hwv_cartan hwv_upper (hwVec η) = hwv :=
  VermaModule.universalMap_hwVec ..

end TriangularDecomposition



section HasCentralValue

variable (M : Type*) [AddCommGroup M] [Module 𝕜 M] [Module (𝓤 𝕜 𝓰) M]

/-- A type class for recording that a (central) element acts as a particular scalar on a
representation. -/
class HasCentralValue (C : 𝓰) (c : 𝕜) where
  central_smul' : ∀ (v : M), ιUEA 𝕜 C • v = c • v

@[simp] lemma HasCentralValue.central_smul {C : 𝓰} {c : 𝕜} [HasCentralValue 𝕜 𝓰 M C c] (v : M) :
    ιUEA 𝕜 C • v = c • v :=
  central_smul' v

end HasCentralValue

end



end VirasoroProject
