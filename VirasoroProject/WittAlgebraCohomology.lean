/-
Copyright (c) 2024 Kalle KytÃ¶lÃ¤. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kalle KytÃ¶lÃ¤
-/
import VirasoroProject.VirasoroCocycle

/-!
# The 2-cohomology of the Witt algebra is generated by the Virasoro cocycle

In this file it is proven that the 2-cohomology of the Witt algebra with scalar coefficients
is one-dimensional, and generated by the Virasoro cocycle.

## Main statements

* `WittAlgebra.exists_add_bdry_eq_smul_virasoroCocycle`: Any Witt algebra 2-cocycle
  can be modified by a coboundary to make it proportional to the Virasoro cocycle.
* `WittAlgebra.rank_lieTwoCohomology_eq_one`: This is (the result of) the calculation of the
  dimension of the 2-cohomology of the Witt algebra, dim HÂ²(WittAlgebra, ğ•œ) = 1.

## Tags

Witt algebra, Lie algebra cohomology

-/

namespace VirasoroProject

namespace WittAlgebra

variable {ğ•œ : Type*} [Field ğ•œ]
variable [CharZero ğ•œ]

variable (Î³ : LieTwoCocycle ğ•œ (WittAlgebra ğ•œ) ğ•œ)

/-- A 1-cocycle of the Witt algebra, which is used to make a 2-cocycle proportional to the
Virasoro cocycle by the addition of the corresponding coboundary. -/
noncomputable def normalizingCocycle : LieOneCocycle ğ•œ (WittAlgebra ğ•œ) ğ•œ where
  toLinearMap := (WittAlgebra.lgen ğ•œ).constr ğ•œ <|
      fun n â†¦ if n = 0
        then (-2â»Â¹ : ğ•œ) â€¢ Î³ (lgen ğ•œ 1) (lgen ğ•œ (-1))
        else (1/n : ğ•œ) â€¢ Î³ (lgen ğ•œ 0) (lgen ğ•œ n)

lemma normalizingCocycle_apply_lgen_zero :
    normalizingCocycle Î³ (lgen ğ•œ 0) = (-2â»Â¹ : ğ•œ) * Î³ (lgen ğ•œ 1) (lgen ğ•œ (-1)) := by
  have aux := (WittAlgebra.lgen ğ•œ).constr_basis ğ•œ (fun n â†¦ if n = 0
        then (-2â»Â¹ : ğ•œ) â€¢ Î³ (lgen ğ•œ 1) (lgen ğ•œ (-1))
        else (1/n : ğ•œ) â€¢ Î³ (lgen ğ•œ 0) (lgen ğ•œ n)) 0
  dsimp at aux
  rw [â† aux]
  congr

lemma normalizingCocycle_apply_lgen (n : â„¤) (hn : n â‰  0) :
    normalizingCocycle Î³ (lgen ğ•œ n) = (1/n : ğ•œ) * Î³ (lgen ğ•œ 0) (lgen ğ•œ n) := by
  have aux := (WittAlgebra.lgen ğ•œ).constr_basis ğ•œ (fun n â†¦ if n = 0
        then (-2â»Â¹ : ğ•œ) â€¢ Î³ (lgen ğ•œ 1) (lgen ğ•œ (-1))
        else (1/n : ğ•œ) â€¢ Î³ (lgen ğ•œ 0) (lgen ğ•œ n)) n
  dsimp at aux
  simp only [hn, â†“reduceIte] at aux
  rw [â† aux]
  congr

lemma add_bdry_normalizingCocycle_apply_lgen_one :
    (Î³ + (normalizingCocycle Î³).bdry) (lgen ğ•œ 1) (lgen ğ•œ (-1)) = 0 := by
  simp only [Int.reduceNeg, LieTwoCocycle.add_apply, LieOneCocycle.bdry_apply, bracket_lgen_lgen,
             Int.cast_one, Int.cast_neg, sub_neg_eq_add, add_neg_cancel, map_smul,
             normalizingCocycle_apply_lgen_zero, neg_mul, smul_eq_mul, mul_neg]
  ring

lemma add_bdry_normalizingCocycle_apply_lgen_zero (n : â„¤) (hn : n â‰  0) :
    (Î³ + (normalizingCocycle Î³).bdry) (lgen ğ•œ 0) (lgen ğ•œ n) = 0 := by
  simp only [LieTwoCocycle.add_apply, LieOneCocycle.bdry_apply, bracket_lgen_lgen, Int.cast_zero,
             zero_sub, zero_add, neg_smul, map_neg, map_smul, smul_eq_mul]
  rw [normalizingCocycle_apply_lgen Î³ n hn]
  simp only [one_div, â† mul_assoc]
  simp [show (n : ğ•œ) * (n : ğ•œ)â»Â¹ = 1 from mul_inv_cancelâ‚€ <| Int.cast_ne_zero.mpr hn]

/-- The 2-cocycle equation in the standard basis `â„“â‚™` of the Witt algebra:
    `0 = (m-k) * Î³(n,m+k) + (k-n) * Î³(m,n+k) + (n-m) * Î³(k,n+m)`. -/
lemma add_lieTwoCocycle_apply_lgen_lgen_lgen_eq_zero (n m k : â„¤) :
    (m - k) * Î³ (lgen ğ•œ n) (lgen ğ•œ (m + k)) + (k - n) * Î³ (lgen ğ•œ m) (lgen ğ•œ (n + k))
     + (n - m) * Î³ (lgen ğ•œ k) (lgen ğ•œ (n + m)) = 0 := by
  have key := Î³.leibniz (X := lgen ğ•œ n) (Y := lgen ğ•œ m) (Z := lgen ğ•œ k)
  simp only [bracket_lgen_lgen, map_smul, smul_eq_mul, LinearMap.smul_apply] at key
  calc    (â†‘m - â†‘k) * (Î³ ((lgen ğ•œ) n)) ((lgen ğ•œ) (m + k))
        + (â†‘k - â†‘n) * (Î³ ((lgen ğ•œ) m)) ((lgen ğ•œ) (n + k))
        + (â†‘n - â†‘m) * (Î³ ((lgen ğ•œ) k)) ((lgen ğ•œ) (n + m))
      =   â†‘n * (Î³ ((lgen ğ•œ) (n + m))) ((lgen ğ•œ) k) - â†‘m * (Î³ ((lgen ğ•œ) (n + m))) ((lgen ğ•œ) k)
        + (â†‘n * (Î³ ((lgen ğ•œ) m)) ((lgen ğ•œ) (n + k)) - â†‘k * (Î³ ((lgen ğ•œ) m)) ((lgen ğ•œ) (n + k)))
        + (â†‘k * (Î³ ((lgen ğ•œ) m)) ((lgen ğ•œ) (n + k)) - â†‘n * (Î³ ((lgen ğ•œ) m)) ((lgen ğ•œ) (n + k)))
        + (â†‘m * (Î³ ((lgen ğ•œ) (n + m))) ((lgen ğ•œ) k) - â†‘n * (Î³ ((lgen ğ•œ) (n + m))) ((lgen ğ•œ) k))
          := by simp only [â† Î³.skew (lgen ğ•œ k), key, sub_mul, mul_neg, neg_sub]
    _ = 0 := by ring

lemma lieTwoCocycle_apply_lgen_lgen_eq_zero_of_add_ne_zero {n m : â„¤} (ne_zero : n + m â‰  0)
    (hÎ³ : Î³ (lgen ğ•œ 0) (lgen ğ•œ (n+m)) = 0) :
    Î³ (lgen ğ•œ n) (lgen ğ•œ m) = 0 := by
  have key := add_lieTwoCocycle_apply_lgen_lgen_lgen_eq_zero Î³ n m 0
  simp only [hÎ³, â† Î³.skew (lgen ğ•œ m), Int.cast_zero, mul_neg, neg_mul, sub_zero,
             add_zero, zero_sub, neg_neg, â† add_mul, mul_zero, mul_eq_zero] at key
  simpa [show (m : ğ•œ) + n â‰  0 by rw [add_comm] ; exact_mod_cast ne_zero] using key

lemma exists_add_bdry_eq_smul_virasoroCocycle :
    âˆƒ (r : ğ•œ), Î³ + (normalizingCocycle Î³).bdry = r â€¢ virasoroCocycle ğ•œ := by
  set Î³â‚€ := Î³ + (normalizingCocycle Î³).bdry -- notation decluttering
  set r := 2 * Î³â‚€ ((lgen ğ•œ) 2) ((lgen ğ•œ) (-2)) with hr -- notation decluttering
  use r
  -- By bilinearity, it suffices to check the equality on basis element pairs.
  suffices âˆ€ (n m : â„¤),
      Î³â‚€ (lgen ğ•œ n) (lgen ğ•œ m) = r * virasoroCocycle ğ•œ (lgen ğ•œ n) (lgen ğ•œ m) by
    apply LieTwoCocycle.ext
    apply (WittAlgebra.lgen ğ•œ).ext fun n â†¦ ?_
    apply (WittAlgebra.lgen ğ•œ).ext fun m â†¦ this n m
  intro n m
  by_cases hnm : n + m = 0
  Â· -- The case n + m = 0 involves the main calculation.
    suffices âˆ€ (k : â„•),
        Î³â‚€ ((lgen ğ•œ) k) ((lgen ğ•œ) (-k : â„¤)) = r * ((k : â„¤)^3 - (k : â„¤)) / 12 by
      simp only [virasoroCocycle_apply_lgen_lgen, hnm, â†“reduceIte]
      by_cases hn : 0 â‰¤ n
      Â· specialize this n.toNat
        have n_eq : n.toNat = n := Int.toNat_of_nonneg hn
        simp_rw [n_eq] at this
        simp_rw [show m = -n by linarith, this, mul_div]
      Â· specialize this m.toNat
        simp only [not_le] at hn
        have m_eq : m.toNat = m := Int.toNat_of_nonneg <| by linarith
        simp_rw [show n = -m by linarith, m_eq] at hn this âŠ¢
        have aux : (-m)^3 = -(m^3) := by
          rw [(pow_eq_neg_pow_iff (by linarith)).mpr âŸ¨rfl, Nat.odd_iff.mpr rflâŸ©]
        rw [â† LieTwoCocycle.skew]
        rw [this]
        simp [show (-m : ğ•œ)^3 = -((m : ğ•œ)^3) by exact_mod_cast aux]
        ring
    intro k
    induction' k using Nat.strong_induction_on with j hj
    by_cases j_small : j âˆˆ ({0, 1, 2} : Finset â„•)
    Â· fin_cases j_small
      Â· -- k = 0 case is true for any cocycle by skew-symmetry
        simp
      Â· -- k = 1 case follows due to the choice of the normalizing coboundary
        convert add_bdry_normalizingCocycle_apply_lgen_one Î³
        ring
      Â· -- k = 2 case is what determines the choice of the multiplicative constant r
        rw [hr]
        norm_num
        ring
    Â· have j_large : 2 < j := by match j with
        | 0 => contradiction | 1 => contradiction | 2 => contradiction
        | j' + 3 => simp
      -- For j â‰¥ 3, the coefficient (2-j) in a key recusive equation does not vanish.
      have not_zero : (2 - j : ğ•œ) â‰  0 := by exact_mod_cast show (2 - j : â„¤) â‰  0 by linarith
      -- The key recursive equation is obtained by taking n = j, m = 1-j, k = -1
      -- in the cocycle condition written in the basis `(â„“â‚™)`.
      -- This equation generally simplifies to
      -- `0 = (2-j) * Î³(j,-j) + (1+j) * Î³(j-1,1-j) + (1-2j) * Î³(1,-1)`
      -- but the last term is zero for `Î³â‚€` because of the normalizing coboundary.
      set j' := j - 1 with hj'
      have aux : (j - 1 : â„¤) = j' := (Int.natCast_pred_of_pos (by linarith)).symm
      have aux' : (1 - j : â„¤) = -j' := by simp [â† aux]
      have eqn : ((2 - j : ğ•œ)) * Î³â‚€ (lgen ğ•œ j) (lgen ğ•œ (-j))
                   + ((1 + j : ğ•œ)) * Î³â‚€ (lgen ğ•œ j') (lgen ğ•œ (-j')) = 0 := by
        have eqn := add_lieTwoCocycle_apply_lgen_lgen_lgen_eq_zero Î³â‚€ j (1-j) (-1)
        simp only [Int.cast_sub, Int.cast_one, Int.cast_natCast, Int.reduceNeg, Int.cast_neg,
                  sub_neg_eq_add, add_sub_cancel] at eqn
        rw [â† Î³â‚€.skew (lgen ğ•œ (-1)), â† Î³â‚€.skew (lgen ğ•œ (1 - j))] at eqn
        have nothing : -(Î³â‚€ ((lgen ğ•œ) 1)) ((lgen ğ•œ) (-1)) = 0 := by
          simpa using hj 1 (by linarith)
        grind
      rw [hj j' (by linarith), hj'] at eqn
      simp only [Int.cast_natCast] at eqn
      rw [add_eq_zero_iff_eq_neg] at eqn
      have solve := congr_arg (fun (z : ğ•œ) â†¦ (2 - j : ğ•œ)â»Â¹ * z) eqn
      simp only [not_zero, isUnit_iff_ne_zero, ne_eq, not_false_eq_true, IsUnit.inv_mul_cancel_left,
                 mul_neg] at solve
      rw [solve, mul_div, mul_div, â† neg_div]
      congr
      calc -((2 - â†‘j)â»Â¹ * ((1 + â†‘j) * (r * (â†‘(j - 1) ^ 3 - â†‘(j - 1)))))
          = -((2 - â†‘j)â»Â¹ * ((1 + â†‘j) * (r * ((â†‘j - 1) ^ 3 - (â†‘j - 1))))) := by
            simp [show (â†‘(j - 1) : ğ•œ) = (â†‘j : ğ•œ) - 1 by exact_mod_cast aux.symm]
        _ = r * -((2 - â†‘j)â»Â¹ * (â†‘j - 2) * (â†‘j ^ 3 - â†‘j))  := by ring
        _ = r * (â†‘j ^ 3 - â†‘j)                             := by field_simp [not_zero, â† neg_mul]
        _ = _                                             := by simp
  Â· -- The case n + m â‰  0 is straightforward by the choice of the normalizing coboundary.
    suffices ((Î³ + (normalizingCocycle Î³).bdry) ((lgen ğ•œ) n)) ((lgen ğ•œ) m) = 0 by
      simpa [virasoroCocycle_apply_lgen_lgen, hnm]
    apply lieTwoCocycle_apply_lgen_lgen_eq_zero_of_add_ne_zero (Î³ + (normalizingCocycle Î³).bdry) hnm
    exact add_bdry_normalizingCocycle_apply_lgen_zero Î³ (n + m) hnm

variable (ğ•œ)

/-- The Lie algebra 2-cohomology of the Witt algebra is one-dimensional,
`dim HÂ²(WittAlgebra, ğ•œ) = 1`. -/
theorem rank_lieTwoCohomology_eq_one :
    Module.rank ğ•œ (LieTwoCohomology ğ•œ (WittAlgebra ğ•œ) ğ•œ) = 1 := by
  apply Module.rank_eq_one_iff_finrank_eq_one.mpr
  apply finrank_eq_one_iff'.mpr
  use (virasoroCocycle ğ•œ).cohomologyClass
  constructor
  Â· exact cohomologyClass_virasoroCocycle_ne_zero ğ•œ
  Â· intro Î³'
    obtain âŸ¨Î³, hÎ³'âŸ© := Quotient.exists_rep Î³'
    obtain âŸ¨r, hrâŸ© := exists_add_bdry_eq_smul_virasoroCocycle Î³
    use r
    convert (LinearMap.congr_arg (f := LieTwoCocycle.toLieTwoCohomology ğ•œ ..) hr).symm
    rw [â† hÎ³']
    exact (LieTwoCocycle.cohomologyClass_add_bdry Î³ (normalizingCocycle Î³)).symm

end WittAlgebra -- namespace

end VirasoroProject -- namespace
