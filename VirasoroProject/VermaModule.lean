/-
Copyright (c) 2025 Kalle KytÃ¶lÃ¤. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kalle KytÃ¶lÃ¤
-/
import Mathlib
import VirasoroProject.LieAlgebraModuleUEA

namespace VirasoroProject



section canonical_map_from_a_ring_to_a_submodule_generated_by_a_vector

variable (R : Type*) [Ring R] {M : Type*} [AddCommGroup M] [Module R M]

/-- A surjective module map from a ring to the submodule generated by a given vector. -/
def Ring.smulVectorâ‚— (m : M) :
    R â†’â‚—[R] M where
  toFun a := a â€¢ m
  map_add' aâ‚ aâ‚‚ := by simp [add_smul]
  map_smul' aâ‚ aâ‚‚ := by simp [mul_smul]

@[simp] lemma Ring.smulVectorâ‚—_one (m : M) :
    smulVectorâ‚— R m 1 = m := by
  simp [smulVectorâ‚—]

lemma Ring.range_smulVectorâ‚—_eq_span (m : M) :
    LinearMap.range (smulVectorâ‚— R m) = Submodule.span R {m} := by
  ext v
  rw [show v âˆˆ Submodule.span R {m} â†” v âˆˆ (Submodule.span R {m} : Set M) from Eq.to_iff rfl]
  rw [Submodule.span_singleton_eq_range R m ]
  simp only [LinearMap.mem_range, Set.mem_range]
  rfl

end canonical_map_from_a_ring_to_a_submodule_generated_by_a_vector



section cyclic_vectors

/-- The submodule spanned by the unit `1` of a ring is the whole ring. -/
lemma one_cyclic {R : Type*} [Semiring R] :
    Submodule.span R {(1 : R)} = âŠ¤ :=
  (Submodule.span_singleton_eq_top_iff R 1).mpr fun a â†¦ âŸ¨a, by simpâŸ©

/-- A surjective linear map maps any cyclic vector (a vector which generates the whole
module) to a cyclic vector. -/
lemma LinearMap.apply_cyclic_of_cyclic_of_surjective {R : Type*} [Semiring R]
    {Mâ‚ Mâ‚‚ : Type*} [AddCommGroup Mâ‚] [AddCommGroup Mâ‚‚] [Module R Mâ‚] [Module R Mâ‚‚]
    {f : Mâ‚ â†’â‚—[R] Mâ‚‚} (f_surj : LinearMap.range f = âŠ¤)
    (m : Mâ‚) (cyclic : Submodule.span R {m} = âŠ¤) :
    Submodule.span R {f m} = âŠ¤ := by
  rw [Submodule.span_singleton_eq_top_iff] at *
  intro mâ‚‚
  obtain âŸ¨mâ‚, hmâŸ© : âˆƒ mâ‚, f mâ‚ = mâ‚‚ := LinearMap.range_eq_top.mp f_surj mâ‚‚
  obtain âŸ¨a, haâŸ© := cyclic mâ‚
  refine âŸ¨a, by rw [â† map_smul, ha, hm]âŸ©

end cyclic_vectors



section left_smul_linear_map

variable (ğ•œ : Type*) [CommRing ğ•œ]
variable {A : Type*} [Semiring A] [Algebra ğ•œ A]
variable (V : Type*) [AddCommGroup V] [Module A V]

def ModuleOfModuleAlgebra.lsmul (a : A) :
    ModuleOfModuleAlgebra ğ•œ A V â†’â‚—[ğ•œ] ModuleOfModuleAlgebra ğ•œ A V where
  toFun v := ModuleOfModuleAlgebra.mkAddHom ğ•œ A V (a â€¢ ModuleOfModuleAlgebra.unMkAddHom ğ•œ A V v)
  map_add' vâ‚ vâ‚‚ :=
    smul_add a (ModuleOfModuleAlgebra.unMkAddHom ğ•œ A V vâ‚) (ModuleOfModuleAlgebra.unMkAddHom ğ•œ A V vâ‚‚)
  map_smul' r v := by
    change a â€¢ (algebraMap ğ•œ A r â€¢ (ModuleOfModuleAlgebra.unMkAddHom ğ•œ A V v))
          = algebraMap ğ•œ A r â€¢ (a â€¢ (ModuleOfModuleAlgebra.unMkAddHom ğ•œ A V v))
    simp [â† smul_assoc]
    congr 1
    exact (Algebra.commutes r a).symm

lemma ModuleOfModuleAlgebra.lsmul_apply (a : A) (v : ModuleOfModuleAlgebra ğ•œ A V) :
    ModuleOfModuleAlgebra.lsmul ğ•œ V a v =
      ModuleOfModuleAlgebra.mkAddHom ğ•œ A V (a â€¢ ModuleOfModuleAlgebra.unMkAddHom ğ•œ A V v) := by
  rfl

end left_smul_linear_map



section generalized_Verma_module

variable {ğ•œ A : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A]
variable {Î¹ : Type*}

/-- The left ideal used in the construction of a (generalized) Verma module for an algebra `A`:
* `B âŠ† A` is a subset meant to act by scalar multiples on the highest weight vector
  (a "Borel subalgebra").
* `Î· : B â†’ ğ•œ` is a is a function giving those scalars ("highest weight" data). -/
def vermaIdeal (Î· : Î¹ â†’ A Ã— ğ•œ) :
    Submodule A A :=
  Submodule.span A (Set.range <| fun (i : Î¹) â†¦ (Î· i).1 - algebraMap ğ•œ A (Î· i).2)

/-- The (generalied) Verma module of an algebra `S` associated to a function `Î· : s â†’ ğ•œ`:
* `ğ“ âŠ† ğ“–` is a (nilpotent) Lie subalgebra meant to act as zero on the highest weight vector,
* `ğ“— âŠ† ğ“–` is a (commutative) Lie subalgebra (Cartan subalgebra) meant to act by scalar
  multiples determined by a functional `Î· : ğ“— â†’ ğ•œ` on the highest weight vector. -/
def VermaModule (Î· : Î¹ â†’ A Ã— ğ•œ) :=
  A â§¸ vermaIdeal Î·

/-- The highest weight vector in a (generalized) Verma module. -/
def VermaModule.hwVec (Î· : Î¹ â†’ A Ã— ğ•œ) :
    VermaModule Î· :=
  Submodule.Quotient.mk 1

instance (Î· : Î¹ â†’ A Ã— ğ•œ) :
    AddCommGroup (VermaModule Î·) :=
  Submodule.Quotient.addCommGroup _

instance (Î· : Î¹ â†’ A Ã— ğ•œ) :
    Module A (VermaModule Î·) :=
  Submodule.Quotient.module _

/-- The highest weight vector in a Verma module is cyclic. -/
lemma VermaModule.hwVec_cyclic (Î· : Î¹ â†’ A Ã— ğ•œ) :
    Submodule.span A {hwVec Î·} = âŠ¤ :=
  LinearMap.apply_cyclic_of_cyclic_of_surjective (Submodule.range_mkQ _) 1 one_cyclic

/-- The defining property of the highest weight vector in a Verma module. -/
lemma VermaModule.apply_hwVec_eq (Î· : Î¹ â†’ A Ã— ğ•œ) (i : Î¹) :
    (Î· i).1 â€¢ hwVec Î· = (algebraMap ğ•œ A (Î· i).2) â€¢ hwVec Î· := by
  rw [show (algebraMap ğ•œ A (Î· i).2) â€¢ hwVec Î·
            = Submodule.Quotient.mk ((algebraMap ğ•œ A (Î· i).2) â€¢ 1) from rfl]
  rw [hwVec, â† Submodule.Quotient.mk_smul, â† sub_eq_zero, â† Submodule.Quotient.mk_sub]
  apply (Submodule.Quotient.mk_eq_zero ..).mpr
  exact Submodule.mem_span_of_mem (by simp)

variable {M : Type*} [AddCommGroup M] [Module A M]

lemma vermaIdeal_le_ker_smulVectorâ‚— (Î· : Î¹ â†’ A Ã— ğ•œ)
    {hwv : M} (hwv_prop : âˆ€ i, (Î· i).1 â€¢ hwv = algebraMap ğ•œ A (Î· i).2 â€¢ hwv) :
    vermaIdeal Î· â‰¤ LinearMap.ker (Ring.smulVectorâ‚— A hwv) := by
  simp only [vermaIdeal, Submodule.span_le]
  intro a âŸ¨i, a_eqâŸ©
  simp only [â† a_eq, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero]
  exact hwv_prop i

/-- The map guaranteed by the universal property of a Verma module. -/
def VermaModule.universalMap (Î· : Î¹ â†’ A Ã— ğ•œ)
    {hwv : M} (hwv_prop : âˆ€ i, (Î· i).1 â€¢ hwv = algebraMap ğ•œ A (Î· i).2 â€¢ hwv) :
    VermaModule Î· â†’â‚—[A] M :=
  Submodule.liftQ (vermaIdeal Î·) (Ring.smulVectorâ‚— A hwv) (vermaIdeal_le_ker_smulVectorâ‚— _ hwv_prop)

/-- The image of the highest weight vector of a Verma module under the map guaranteed by the
universal property is the assigned highest weight vector in the image module. -/
@[simp] lemma VermaModule.universalMap_hwVec (Î· : Î¹ â†’ A Ã— ğ•œ)
    {hwv : M} (hwv_prop : âˆ€ i, (Î· i).1 â€¢ hwv = algebraMap ğ•œ A (Î· i).2 â€¢ hwv) :
    universalMap Î· hwv_prop (hwVec Î·) = hwv := by
  convert Submodule.liftQ_apply (vermaIdeal Î·) (Ring.smulVectorâ‚— A hwv) 1
  simp

/-- The range of the map guaranteed by the universal property of a Verma module is the submodule
generated by the assigned highest weight vector in the image module. -/
lemma VermaModule.range_universalMap_eq_span (Î· : Î¹ â†’ A Ã— ğ•œ)
    {hwv : M} (hwv_prop : âˆ€ i, (Î· i).1 â€¢ hwv = algebraMap ğ•œ A (Î· i).2 â€¢ hwv) :
    LinearMap.range (universalMap Î· hwv_prop) = Submodule.span A {hwv} := by
  have key := VermaModule.hwVec_cyclic Î· â–¸ Submodule.map_top (universalMap Î· hwv_prop)
  simp [â† key, Submodule.map_span]

end generalized_Verma_module


end VirasoroProject
