import Mathlib

namespace VirasoroProject

section generalized_Verma_module

--/-- The left ideal used in the construction of a (generalized) Verma module for an algebra `A`:
--* `B âŠ† A` is a subset meant to act by scalar multiples on the highest weight vector
--  (a "Borel subalgebra").
--* `Î· : B â†’ ğ•œ` is a is a function giving those scalars ("highest weight" data). -/
--def vermaIdeal'' {ğ•œ A : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A]
--    {B : Set A} (Î· : B â†’ ğ•œ) :
--    Submodule A A :=
--  Submodule.span A (Set.range <| fun (b : B) â†¦ b - algebraMap ğ•œ A (Î· b))

/-- The left ideal used in the construction of a (generalized) Verma module for an algebra `A`:
* `B âŠ† A` is a subset meant to act by scalar multiples on the highest weight vector
  (a "Borel subalgebra").
* `Î· : B â†’ ğ•œ` is a is a function giving those scalars ("highest weight" data). -/
def vermaIdeal {Î¹ : Type*} {ğ•œ A : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A]
    (Î· : Î¹ â†’ A Ã— ğ•œ) :
    Submodule A A :=
  Submodule.span A (Set.range <| fun (i : Î¹) â†¦ (Î· i).1 - algebraMap ğ•œ A (Î· i).2)

--/-- The (generalied) Verma module of an algebra `S` associated to a function `Î· : s â†’ ğ•œ`:
--* `ğ“ âŠ† ğ“–` is a (nilpotent) Lie subalgebra meant to act as zero on the highest weight vector,
--* `ğ“— âŠ† ğ“–` is a (commutative) Lie subalgebra (Cartan subalgebra) meant to act by scalar
--  multiples determined by a functional `Î· : ğ“— â†’ ğ•œ` on the highest weight vector. -/
--def VermaModule'' {ğ•œ A : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A]
--    {B : Set A} (Î· : B â†’ ğ•œ) :=
--  A â§¸ vermaIdeal'' Î·

/-- The (generalied) Verma module of an algebra `S` associated to a function `Î· : s â†’ ğ•œ`:
* `ğ“ âŠ† ğ“–` is a (nilpotent) Lie subalgebra meant to act as zero on the highest weight vector,
* `ğ“— âŠ† ğ“–` is a (commutative) Lie subalgebra (Cartan subalgebra) meant to act by scalar
  multiples determined by a functional `Î· : ğ“— â†’ ğ•œ` on the highest weight vector. -/
def VermaModule {ğ•œ A Î¹ : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A]
    (Î· : Î¹ â†’ A Ã— ğ•œ) :=
  A â§¸ vermaIdeal Î·

--/-- The highest weight vector in a (generalized) Verma module. -/
--def VermaModule.hwVec'' {ğ•œ A : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] {B : Set A} (Î· : B â†’ ğ•œ) :
--    VermaModule'' Î· :=
--  Submodule.Quotient.mk 1

/-- The highest weight vector in a (generalized) Verma module. -/
def VermaModule.hwVec {ğ•œ A Î¹ : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] (Î· : Î¹ â†’ A Ã— ğ•œ) :
    VermaModule Î· :=
  Submodule.Quotient.mk 1

--instance {ğ•œ A : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] {B : Set A} (Î· : B â†’ ğ•œ) :
--    AddCommGroup (VermaModule'' Î·) :=
--  Submodule.Quotient.addCommGroup _
--
--instance {ğ•œ A : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] {B : Set A} (Î· : B â†’ ğ•œ) :
--    Module A (VermaModule'' Î·) :=
--  Submodule.Quotient.module _

instance {ğ•œ A Î¹ : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] (Î· : Î¹ â†’ A Ã— ğ•œ) :
    AddCommGroup (VermaModule Î·) :=
  Submodule.Quotient.addCommGroup _

instance {ğ•œ A Î¹ : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] (Î· : Î¹ â†’ A Ã— ğ•œ) :
    Module A (VermaModule Î·) :=
  Submodule.Quotient.module _

--/-- The defining property of the highest weight vector in a Verma module. -/
--lemma VermaModule.apply_hwVec_eq''
--    {ğ•œ A : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] {B : Set A} (Î· : B â†’ ğ•œ)
--    {a : A} (a_in_B : a âˆˆ B) :
--    a â€¢ hwVec'' Î· = (algebraMap ğ•œ A (Î· âŸ¨a, a_in_BâŸ©)) â€¢ hwVec'' Î· := by
--  have auxâ‚ : a â€¢ hwVec'' Î· = Submodule.Quotient.mk (a â€¢ 1) := rfl
--  have auxâ‚‚ : (algebraMap ğ•œ A (Î· âŸ¨a, a_in_BâŸ©)) â€¢ hwVec'' Î·
--              = Submodule.Quotient.mk ((algebraMap ğ•œ A (Î· âŸ¨a, a_in_BâŸ©)) â€¢ 1) :=
--    rfl
--  simp only [auxâ‚, auxâ‚‚, smul_eq_mul, mul_one]
--  rw [â† sub_eq_zero, â† Submodule.Quotient.mk_sub]
--  apply (Submodule.Quotient.mk_eq_zero ..).mpr
--  apply Submodule.mem_span_of_mem
--  exact Set.mem_range.mpr âŸ¨âŸ¨a, a_in_BâŸ©, by simpâŸ©

/-- The defining property of the highest weight vector in a Verma module. -/
lemma VermaModule.apply_hwVec_eq
    {ğ•œ A Î¹ : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] (Î· : Î¹ â†’ A Ã— ğ•œ) (i : Î¹) :
    (Î· i).1 â€¢ hwVec Î· = (algebraMap ğ•œ A (Î· i).2) â€¢ hwVec Î· := by
  rw [show (algebraMap ğ•œ A (Î· i).2) â€¢ hwVec Î·
            = Submodule.Quotient.mk ((algebraMap ğ•œ A (Î· i).2) â€¢ 1) from rfl]
  rw [hwVec, â† Submodule.Quotient.mk_smul, â† sub_eq_zero, â† Submodule.Quotient.mk_sub]
  apply (Submodule.Quotient.mk_eq_zero ..).mpr
  exact Submodule.mem_span_of_mem (by simp)

/-- A surjective module map from a ring to the submodule generated by a given vector. -/
def Ring.smulVectorâ‚— (A : Type*) [Ring A] {M : Type*} [AddCommGroup M] [Module A M] (m : M) :
    A â†’â‚—[A] M where
  toFun a := a â€¢ m
  map_add' aâ‚ aâ‚‚ := by simp [add_smul]
  map_smul' aâ‚ aâ‚‚ := by simp [mul_smul]

@[simp] lemma Ring.smulVectorâ‚—_one (A : Type*) [Ring A] {M : Type*} [AddCommGroup M] [Module A M]
    (m : M) :
    smulVectorâ‚— A m 1 = m := by
  simp [smulVectorâ‚—]

lemma Ring.range_smulVectorâ‚—_eq_span (A : Type*) [Ring A]
    {M : Type*} [AddCommGroup M] [Module A M] (m : M) :
    LinearMap.range (smulVectorâ‚— A m) = Submodule.span A {m} := by
  ext v
  rw [show v âˆˆ Submodule.span A {m} â†” v âˆˆ (Submodule.span A {m} : Set M) from Eq.to_iff rfl]
  rw [Submodule.span_singleton_eq_range A m ]
  simp only [LinearMap.mem_range, Set.mem_range]
  rfl

--lemma vermaIdeal_le_ker_smulVectorâ‚—'' {ğ•œ A : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A]
--    {B : Set A} (Î· : B â†’ ğ•œ) {M : Type*} [AddCommGroup M] [Module A M]
--    {hwv : M} (hwv_prop : âˆ€ {b} (hb : b âˆˆ B), b â€¢ hwv = algebraMap ğ•œ A (Î· âŸ¨b, hbâŸ©) â€¢ hwv) :
--    vermaIdeal'' Î· â‰¤ LinearMap.ker (Ring.smulVectorâ‚— A hwv) := by
--  simp only [vermaIdeal'', Submodule.span_le]
--  intro a âŸ¨b, a_eqâŸ©
--  simp only [â† a_eq, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero]
--  exact hwv_prop b.prop

lemma vermaIdeal_le_ker_smulVectorâ‚— {ğ•œ A Î¹ : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A]
    (Î· : Î¹ â†’ A Ã— ğ•œ) {M : Type*} [AddCommGroup M] [Module A M]
    {hwv : M} (hwv_prop : âˆ€ i, (Î· i).1 â€¢ hwv = algebraMap ğ•œ A (Î· i).2 â€¢ hwv) :
    vermaIdeal Î· â‰¤ LinearMap.ker (Ring.smulVectorâ‚— A hwv) := by
  simp only [vermaIdeal, Submodule.span_le]
  intro a âŸ¨i, a_eqâŸ©
  simp only [â† a_eq, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero]
  exact hwv_prop i

--/-- The map guaranteed by the universal property of a Verma module. -/
--def VermaModule.universalMap''
--    {ğ•œ A : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] {B : Set A} (Î· : B â†’ ğ•œ)
--    {M : Type*} [AddCommGroup M] [Module A M]
--    {hwv : M} (hwv_prop : âˆ€ {b} (hb : b âˆˆ B), b â€¢ hwv = algebraMap ğ•œ A (Î· âŸ¨b, hbâŸ©) â€¢ hwv) :
--    VermaModule'' Î· â†’â‚—[A] M :=
--  Submodule.liftQ (vermaIdeal'' Î·) (Ring.smulVectorâ‚— A hwv) (vermaIdeal_le_ker_smulVectorâ‚—'' _ hwv_prop)

/-- The map guaranteed by the universal property of a Verma module. -/
def VermaModule.universalMap
    {ğ•œ A Î¹ : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] (Î· : Î¹ â†’ A Ã— ğ•œ)
    {M : Type*} [AddCommGroup M] [Module A M]
    {hwv : M} (hwv_prop : âˆ€ i, (Î· i).1 â€¢ hwv = algebraMap ğ•œ A (Î· i).2 â€¢ hwv) :
    VermaModule Î· â†’â‚—[A] M :=
  Submodule.liftQ (vermaIdeal Î·) (Ring.smulVectorâ‚— A hwv) (vermaIdeal_le_ker_smulVectorâ‚— _ hwv_prop)

--/-- The image of the highest weight vector of a Verma module under the map guaranteed by the
--universal property is the assigned highest weight vector in the image module. -/
--@[simp] lemma VermaModule.universalMap_hwVec''
--    {ğ•œ A : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] {B : Set A} (Î· : B â†’ ğ•œ)
--    (M : Type*) [AddCommGroup M] [Module A M]
--    (hwv : M) (hwv_prop : âˆ€ {b} (hb : b âˆˆ B), b â€¢ hwv = algebraMap ğ•œ A (Î· âŸ¨b, hbâŸ©) â€¢ hwv) :
--    universalMap'' Î· hwv_prop (hwVec'' Î·) = hwv := by
--  convert Submodule.liftQ_apply (vermaIdeal'' Î·) (Ring.smulVectorâ‚— A hwv) 1
--  simp

/-- The image of the highest weight vector of a Verma module under the map guaranteed by the
universal property is the assigned highest weight vector in the image module. -/
@[simp] lemma VermaModule.universalMap_hwVec
    {ğ•œ A Î¹ : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] (Î· : Î¹ â†’ A Ã— ğ•œ)
    (M : Type*) [AddCommGroup M] [Module A M]
    (hwv : M) (hwv_prop : âˆ€ i, (Î· i).1 â€¢ hwv = algebraMap ğ•œ A (Î· i).2 â€¢ hwv) :
    universalMap Î· hwv_prop (hwVec Î·) = hwv := by
  convert Submodule.liftQ_apply (vermaIdeal Î·) (Ring.smulVectorâ‚— A hwv) 1
  simp

--/-- The range of the map guaranteed by the universal property of a Verma module is the submodule
--generated by the assigned highest weight vector in the image module. -/
--lemma VermaModule.range_universalMap_eq_span''
--    {ğ•œ A : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] {B : Set A} (Î· : B â†’ ğ•œ)
--    {M : Type*} [AddCommGroup M] [Module A M]
--    {hwv : M} (hwv_prop : âˆ€ {b} (hb : b âˆˆ B), b â€¢ hwv = algebraMap ğ•œ A (Î· âŸ¨b, hbâŸ©) â€¢ hwv)
--    (c : A) :
--    LinearMap.range (universalMap'' Î· hwv_prop) = Submodule.span A {hwv} := by
--  sorry

/-- The range of the map guaranteed by the universal property of a Verma module is the submodule
generated by the assigned highest weight vector in the image module. -/
lemma VermaModule.range_universalMap_eq_span
    {ğ•œ A Î¹ : Type*} [CommRing ğ•œ] [Ring A] [Algebra ğ•œ A] (Î· : Î¹ â†’ A Ã— ğ•œ)
    {M : Type*} [AddCommGroup M] [Module A M]
    {hwv : M} (hwv_prop : âˆ€ i, (Î· i).1 â€¢ hwv = algebraMap ğ•œ A (Î· i).2 â€¢ hwv)
    (c : A) :
    LinearMap.range (universalMap Î· hwv_prop) = Submodule.span A {hwv} := by
  sorry

end generalized_Verma_module



section

variable (ğ•œ : Type*) [CommRing ğ•œ]
variable (ğ“– : Type*) [LieRing ğ“–] [LieAlgebra ğ•œ ğ“–]
variable (ğ“ ğ“— : LieSubalgebra ğ•œ ğ“–) (Î· : ğ“— â†’â‚—[ğ•œ] ğ•œ)

@[inherit_doc UniversalEnvelopingAlgebra]
abbrev ğ“¤ := UniversalEnvelopingAlgebra

#check ğ“¤ ğ•œ ğ“–

--set_option linter.unusedVariables false in
--/-- Highest weight data constructed from
--* `ğ“ âŠ† ğ“–` is a (nilpotent) Lie subalgebra meant to act as zero on the highest weight vector;
--* `ğ“— âŠ† ğ“–` is a (commutative) Lie subalgebra (Cartan subalgebra) meant to act by scalar
--  multiples on the highest weight vector;
--* `Î· : ğ“— â†’ ğ•œ` is a functional determining the above mentioned scalars. -/
----def highestWeightData (Î· : ğ“— â†’â‚—[ğ•œ] ğ•œ) :
----  â†‘((UniversalEnvelopingAlgebra.Î¹ ğ•œ '' (((ğ“—.toSubmodule) âŠ” (ğ“.toSubmodule)) : Set ğ“–))) â†’ ğ•œ :=
----  fun X â†¦ by -- **TODO:** Rubbish placeholder, think about the best way.
----    have (Y) (hY : Y âˆˆ ğ“—.toSubmodule âŠ” ğ“.toSubmodule) : âˆƒ H âˆˆ ğ“—, âˆƒ N âˆˆ ğ“, Y = H + N := by
----      obtain âŸ¨H, hH, N, hN, rflâŸ© := Submodule.mem_sup.mp hY
----      exact âŸ¨H, hH, N, hN, rflâŸ©
----    have : X.val âˆˆ UniversalEnvelopingAlgebra.Î¹ ğ•œ '' (ğ“—.toSubmodule âŠ” ğ“.toSubmodule) :=
----      Subtype.coe_prop X
----    have : âˆƒ Y âˆˆ ğ“—.toSubmodule âŠ” ğ“.toSubmodule, X.val = UniversalEnvelopingAlgebra.Î¹ ğ•œ Y := by
----      --rw [Set.mem_image] at this
----      obtain âŸ¨X', hX', Î¹X'âŸ© := (Set.mem_image ..).mp this
----      refine âŸ¨X', ?_, ?_âŸ©
----
----      sorry
----    --cases' X with Y hY
----    sorry
--def highestWeightData (Î· : ğ“— â†’â‚—[ğ•œ] ğ•œ) :
--  â†‘((UniversalEnvelopingAlgebra.Î¹ ğ•œ '' ğ“) âˆª (UniversalEnvelopingAlgebra.Î¹ ğ•œ '' (ğ“— : Set ğ“–))) â†’ ğ•œ :=
--  fun _ â†¦ 0 -- **TODO:** Rubbish placeholder, think about the best way.
--
--variable {ğ“– ğ“—} in
--/-- The left ideal used in the construction of a Verma module:
--* `ğ“ âŠ† ğ“–` is a (nilpotent) Lie subalgebra meant to act as zero on the highest weight vector,
--* `ğ“— âŠ† ğ“–` is a (commutative) Lie subalgebra (Cartan subalgebra) meant to act by scalar
--  multiples determined by a functional `Î· : ğ“— â†’ ğ•œ` on the highest weight vector. -/
--def UniversalEnvelopingAlgebra.vermaIdeal :
--    Submodule (ğ“¤ ğ•œ ğ“–) (ğ“¤ ğ•œ ğ“–) :=
--  vermaIdeal (ğ•œ := ğ•œ) (A := (ğ“¤ ğ•œ ğ“–)) (highestWeightData ğ•œ ğ“– ğ“ ğ“— Î·)
----  Ideal.span (Set.range <| fun (H : ğ“—) â†¦ Î¹ ğ•œ (H : ğ“–) - Î· H â€¢ 1)
----    âŠ” Ideal.span (ğ“.map (Î¹ ğ•œ) : Set (ğ“¤ ğ•œ ğ“–))
--
--/-
--variable {ğ“– ğ“—} in
--/-- The Verma module of a Lie algebra `ğ“–` associated to data:
-- * `ğ“ âŠ† ğ“–` is a (nilpotent) Lie subalgebra meant to act as zero on the highest weight vector,
-- * `ğ“— âŠ† ğ“–` is a (commutative) Lie subalgebra (Cartan subalgebra) meant to act by scalar
--   multiples determined by a functional `Î· : ğ“— â†’ ğ•œ` on the highest weight vector. -/
--def vermaModule :=
--  ğ“¤ ğ•œ ğ“– â§¸ UniversalEnvelopingAlgebra.vermaIdeal ğ•œ ğ“ Î·
--
--instance : AddCommGroup (vermaModule ğ•œ ğ“ Î·) :=
--  Submodule.Quotient.addCommGroup _
--
--instance : Module (ğ“¤ ğ•œ ğ“–) (vermaModule ğ•œ ğ“ Î·) :=
--  Submodule.Quotient.module _
--
--/-- Make any module over an algebra into a module over the scalars.
--(Is this a bad idea as an instance? I think this is near essential both for palatable
--notation and for being able to talk about vector subspaces and submodules of a module
--over a noncommutative algebra.) -/
--def moduleScalarOfModule (R A M : Type*)
--    [CommRing R] [Semiring A] [Algebra R A] [AddCommMonoid M] [Module A M] :
--    Module R M where
--  smul c v := (algebraMap R A c) â€¢ v
--  one_smul v := by
--    change (algebraMap R A 1) â€¢ v = v
--    simp
--  mul_smul câ‚ câ‚‚ v := by
--    change (algebraMap R A (câ‚ * câ‚‚)) â€¢ v = (algebraMap R A câ‚) â€¢ (algebraMap R A câ‚‚ â€¢ v)
--    simp [â† mul_smul]
--  smul_zero c := by
--    change (algebraMap R A c) â€¢ (0 : M) = 0
--    simp
--  smul_add c vâ‚ vâ‚‚ := by
--    change (algebraMap R A c) â€¢ (vâ‚ + vâ‚‚) = (algebraMap R A c) â€¢ vâ‚ + (algebraMap R A c) â€¢ vâ‚‚
--    simp
--  add_smul câ‚ câ‚‚ v := by
--    change (algebraMap R A (câ‚ + câ‚‚)) â€¢ v = (algebraMap R A câ‚) â€¢ v + (algebraMap R A câ‚‚) â€¢ v
--    simp [add_smul]
--  zero_smul v := by
--    change (algebraMap R A 0) â€¢ v = 0
--    simp
--
----instance (R A M : Type*) [CommRing R] [Semiring A] [Algebra R A] [AddCommMonoid M] [Module A M] :
----    SMul R M where
----  smul c v := (c â€¢ (1 : A)) â€¢ v
--
----open UniversalEnvelopingAlgebra in
----/-- The universal property of a Verma module. -/
----def vermaModule.lift' (M : Type*) [AddCommGroup M] [Module (ğ“¤ ğ•œ ğ“–) M]
----    (hvw : M) (hvwN : âˆ€ (N : ğ“), (UniversalEnvelopingAlgebra.Î¹ ğ•œ (N : ğ“–) â€¢ hvw = 0))
----    (hvwH : âˆ€ (H : ğ“—), (Î¹ ğ•œ (H : ğ“–) â€¢ hvw = (Î· H â€¢ (1 : ğ“¤ ğ•œ ğ“–)) â€¢ hvw)) :
----    vermaModule ğ•œ ğ“ Î· â†’â‚—[ğ“¤ ğ•œ ğ“–] M :=
----  let f : ğ“¤ ğ•œ ğ“– â†’â‚—[ğ“¤ ğ•œ ğ“–] M := {
----    toFun U := U â€¢ hvw
----    map_add' Uâ‚ Uâ‚‚ := by simp [add_smul]
----    map_smul' Uâ‚ Uâ‚‚ := by simp [mul_smul] }
----  Submodule.liftQ (vermaIdeal ğ•œ ğ“ Î·) f <| sup_le_iff.mpr
----    âŸ¨ by
----        apply Ideal.span_le.mpr
----        intro H' âŸ¨H, hHâŸ©
----        simpa only [â† hH, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero] using hvwH H,
----      by
----        apply Ideal.span_le.mpr
----        intro N' âŸ¨N, N_mem, Î¹N_eqâŸ©
----        simpa [â† Î¹N_eq] using hvwN âŸ¨N, N_memâŸ©âŸ©

end

end VirasoroProject
