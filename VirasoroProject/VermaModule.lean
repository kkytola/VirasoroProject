/-
Copyright (c) 2025 Kalle Kyt√∂l√§. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kalle Kyt√∂l√§
-/
import Mathlib
import VirasoroProject.LieAlgebraModuleUEA

namespace VirasoroProject



section canonical_map_from_a_ring_to_a_submodule_generated_by_a_vector

variable (R : Type*) [Ring R] {M : Type*} [AddCommGroup M] [Module R M]

/-- A surjective module map from a ring to the submodule generated by a given vector. -/
def Ring.smulVector‚Çó (m : M) :
    R ‚Üí‚Çó[R] M where
  toFun a := a ‚Ä¢ m
  map_add' a‚ÇÅ a‚ÇÇ := by simp [add_smul]
  map_smul' a‚ÇÅ a‚ÇÇ := by simp [mul_smul]

@[simp] lemma Ring.smulVector‚Çó_one (m : M) :
    smulVector‚Çó R m 1 = m := by
  simp [smulVector‚Çó]

lemma Ring.range_smulVector‚Çó_eq_span (m : M) :
    LinearMap.range (smulVector‚Çó R m) = Submodule.span R {m} := by
  ext v
  rw [show v ‚àà Submodule.span R {m} ‚Üî v ‚àà (Submodule.span R {m} : Set M) from Eq.to_iff rfl]
  rw [Submodule.span_singleton_eq_range R m ]
  simp only [LinearMap.mem_range, Set.mem_range]
  rfl

end canonical_map_from_a_ring_to_a_submodule_generated_by_a_vector



section cyclic_vectors

/-- The submodule spanned by the unit `1` of a ring is the whole ring. -/
lemma one_cyclic {R : Type*} [Semiring R] :
    Submodule.span R {(1 : R)} = ‚ä§ :=
  (Submodule.span_singleton_eq_top_iff R 1).mpr fun a ‚Ü¶ ‚ü®a, by simp‚ü©

/-- A surjective linear map maps any cyclic vector (a vector which generates the whole
module) to a cyclic vector. -/
lemma LinearMap.apply_cyclic_of_cyclic_of_surjective {R : Type*} [Semiring R]
    {M‚ÇÅ M‚ÇÇ : Type*} [AddCommGroup M‚ÇÅ] [AddCommGroup M‚ÇÇ] [Module R M‚ÇÅ] [Module R M‚ÇÇ]
    {f : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ} (f_surj : LinearMap.range f = ‚ä§)
    (m : M‚ÇÅ) (cyclic : Submodule.span R {m} = ‚ä§) :
    Submodule.span R {f m} = ‚ä§ := by
  rw [Submodule.span_singleton_eq_top_iff] at *
  intro m‚ÇÇ
  obtain ‚ü®m‚ÇÅ, hm‚ü© : ‚àÉ m‚ÇÅ, f m‚ÇÅ = m‚ÇÇ := LinearMap.range_eq_top.mp f_surj m‚ÇÇ
  obtain ‚ü®a, ha‚ü© := cyclic m‚ÇÅ
  refine ‚ü®a, by rw [‚Üê map_smul, ha, hm]‚ü©

end cyclic_vectors



section generalized_Verma_module

variable {ùïú A : Type*} [CommRing ùïú] [Ring A] [Algebra ùïú A]
variable {Œπ : Type*}

/-- The left ideal used in the construction of a (generalized) Verma module for an algebra `A`:
`Œ∑ : Œπ ‚Üí A √ó ùïú` is an indexed collection of algebra elements and scalars by which they should act
on the "highest weight vector". -/
def vermaIdeal (Œ∑ : Œπ ‚Üí A √ó ùïú) :
    Submodule A A :=
  Submodule.span A (Set.range <| fun (i : Œπ) ‚Ü¶ (Œ∑ i).1 - algebraMap ùïú A (Œ∑ i).2)

/-- The (generalied) Verma module of an algebra `A`:
`Œ∑ : Œπ ‚Üí A √ó ùïú` is an indexed collection of algebra elements and scalars by which they should act
on the "highest weight vector". -/
def VermaModule (Œ∑ : Œπ ‚Üí A √ó ùïú) :=
  A ‚ß∏ vermaIdeal Œ∑

/-- The highest weight vector in a (generalized) Verma module. -/
def VermaModule.hwVec (Œ∑ : Œπ ‚Üí A √ó ùïú) :
    VermaModule Œ∑ :=
  Submodule.Quotient.mk 1

instance (Œ∑ : Œπ ‚Üí A √ó ùïú) :
    AddCommGroup (VermaModule Œ∑) :=
  Submodule.Quotient.addCommGroup _

instance (Œ∑ : Œπ ‚Üí A √ó ùïú) :
    Module A (VermaModule Œ∑) :=
  Submodule.Quotient.module _

/-- The highest weight vector in a Verma module is cyclic. -/
lemma VermaModule.hwVec_cyclic (Œ∑ : Œπ ‚Üí A √ó ùïú) :
    Submodule.span A {hwVec Œ∑} = ‚ä§ :=
  LinearMap.apply_cyclic_of_cyclic_of_surjective (Submodule.range_mkQ _) 1 one_cyclic

/-- The defining property of the highest weight vector in a Verma module. -/
lemma VermaModule.apply_hwVec_eq (Œ∑ : Œπ ‚Üí A √ó ùïú) (i : Œπ) :
    (Œ∑ i).1 ‚Ä¢ hwVec Œ∑ = (algebraMap ùïú A (Œ∑ i).2) ‚Ä¢ hwVec Œ∑ := by
  rw [show (algebraMap ùïú A (Œ∑ i).2) ‚Ä¢ hwVec Œ∑
            = Submodule.Quotient.mk ((algebraMap ùïú A (Œ∑ i).2) ‚Ä¢ 1) from rfl]
  rw [hwVec, ‚Üê Submodule.Quotient.mk_smul, ‚Üê sub_eq_zero, ‚Üê Submodule.Quotient.mk_sub]
  apply (Submodule.Quotient.mk_eq_zero ..).mpr
  exact Submodule.mem_span_of_mem (by simp)

variable {M : Type*} [AddCommGroup M] [Module A M]

lemma vermaIdeal_le_ker_smulVector‚Çó (Œ∑ : Œπ ‚Üí A √ó ùïú)
    {hwv : M} (hwv_prop : ‚àÄ i, (Œ∑ i).1 ‚Ä¢ hwv = algebraMap ùïú A (Œ∑ i).2 ‚Ä¢ hwv) :
    vermaIdeal Œ∑ ‚â§ LinearMap.ker (Ring.smulVector‚Çó A hwv) := by
  simp only [vermaIdeal, Submodule.span_le]
  intro a ‚ü®i, a_eq‚ü©
  simp only [‚Üê a_eq, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero]
  exact hwv_prop i

/-- The map guaranteed by the universal property of a Verma module. -/
def VermaModule.universalMap (Œ∑ : Œπ ‚Üí A √ó ùïú)
    {hwv : M} (hwv_prop : ‚àÄ i, (Œ∑ i).1 ‚Ä¢ hwv = algebraMap ùïú A (Œ∑ i).2 ‚Ä¢ hwv) :
    VermaModule Œ∑ ‚Üí‚Çó[A] M :=
  Submodule.liftQ (vermaIdeal Œ∑) (Ring.smulVector‚Çó A hwv) (vermaIdeal_le_ker_smulVector‚Çó _ hwv_prop)

/-- The image of the highest weight vector of a Verma module under the map guaranteed by the
universal property is the assigned highest weight vector in the image module. -/
@[simp] lemma VermaModule.universalMap_hwVec (Œ∑ : Œπ ‚Üí A √ó ùïú)
    {hwv : M} (hwv_prop : ‚àÄ i, (Œ∑ i).1 ‚Ä¢ hwv = algebraMap ùïú A (Œ∑ i).2 ‚Ä¢ hwv) :
    universalMap Œ∑ hwv_prop (hwVec Œ∑) = hwv := by
  convert Submodule.liftQ_apply (vermaIdeal Œ∑) (Ring.smulVector‚Çó A hwv) 1
  simp

/-- The range of the map guaranteed by the universal property of a Verma module is the submodule
generated by the assigned highest weight vector in the image module. -/
lemma VermaModule.range_universalMap_eq_span (Œ∑ : Œπ ‚Üí A √ó ùïú)
    {hwv : M} (hwv_prop : ‚àÄ i, (Œ∑ i).1 ‚Ä¢ hwv = algebraMap ùïú A (Œ∑ i).2 ‚Ä¢ hwv) :
    LinearMap.range (universalMap Œ∑ hwv_prop) = Submodule.span A {hwv} := by
  have key := VermaModule.hwVec_cyclic Œ∑ ‚ñ∏ Submodule.map_top (universalMap Œ∑ hwv_prop)
  simp [‚Üê key, Submodule.map_span]

end generalized_Verma_module


end VirasoroProject
